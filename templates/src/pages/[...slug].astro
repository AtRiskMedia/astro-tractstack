---
import Layout from '@/layouts/Layout.astro';
import type { AuthStatus } from '@/types.ts';

const user = Astro.locals.user as AuthStatus;
const tenantId = Astro.locals.tenant?.id || 'default';

const { slug } = Astro.params;
const lookup = slug || '';

const goBackend = import.meta.env.PUBLIC_GO_BACKEND || 'http://localhost:8080';

const endpoint = lookup
  ? `${goBackend}/api/v1/nodes/storyfragments/slug/${lookup}`
  : `${goBackend}/api/v1/nodes/storyfragments/home`;

let storyData;
try {
  const response = await fetch(endpoint, {
    headers: {
      'X-Tenant-ID': tenantId,
    },
  });

  if (!response.ok) {
    return new Response(null, {
      status: 404,
      statusText: 'Story not found',
    });
  }

  storyData = await response.json();
} catch (error) {
  console.error('Error fetching storyfragment:', error);
  return new Response(null, {
    status: 500,
    statusText: 'Failed to load story',
  });
}

if (!storyData) {
  return new Response(null, {
    status: 404,
    statusText: 'Story not found',
  });
}

const storyfragmentId = storyData.id;
const storyfragmentTitle = storyData.title || 'Untitled Story';
const paneIds = storyData.paneIds || [];

// Server-side batch render all fragments (no personalization)
let fragmentsData = {};
try {
  const batchResponse = await fetch(`${goBackend}/api/v1/fragments/panes`, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'X-Tenant-ID': tenantId,
      // No session headers - will get non-personalized content
    },
    body: JSON.stringify({ paneIds: paneIds }),
  });

  if (batchResponse.ok) {
    const batchData = await batchResponse.json();
    fragmentsData = batchData.fragments || {};

    // Handle any errors from the batch response
    if (batchData.errors) {
      Object.entries(batchData.errors).forEach(([paneId, error]) => {
        fragmentsData[paneId] =
          `<div class="error">Failed to load pane ${paneId}: ${error}</div>`;
      });
    }
  } else {
    console.error('Batch fragment request failed:', batchResponse.status);
    // Fallback: create error messages for all panes
    paneIds.forEach((paneId) => {
      fragmentsData[paneId] =
        `<div class="error">Failed to load pane ${paneId}</div>`;
    });
  }
} catch (error) {
  console.error('Error fetching fragments batch:', error);
  // Fallback: create error messages for all panes
  paneIds.forEach((paneId) => {
    fragmentsData[paneId] =
      `<div class="error">Error loading pane ${paneId}</div>`;
  });
}
---

<Layout title={storyfragmentTitle}>
  <div class="border-b bg-gray-100 p-4">
    <h1 class="text-2xl font-bold">{storyfragmentTitle}</h1>
    <p class="text-sm text-gray-600">
      Header placeholder - slug: {lookup || 'home'}
    </p>
  </div>

  <main id="main-content" class="min-h-screen w-full">
    <div class="panes-container">
      {
        paneIds.map((paneId: string) => (
          <div
            key={paneId}
            data-pane-id={paneId}
            class="pane-fragment-container border-b p-4"
            hx-get={`${goBackend}/api/v1/fragments/panes/${paneId}`}
            hx-trigger="refresh"
            hx-swap="innerHTML"
            set:html={fragmentsData[paneId]}
          />
        ))
      }
    </div>
  </main>

  <div class="border-t bg-gray-100 p-4">
    <p class="text-sm text-gray-600">Footer placeholder</p>
  </div>
</Layout>

<script define:vars={{ goBackend, storyfragmentId, tenantId }}>
  console.log('🟢 SCRIPT START: Variables received:', {
    goBackend,
    storyfragmentId,
    tenantId,
  });

  const BACKEND_URL = goBackend;
  const STORYFRAGMENT_ID = storyfragmentId;
  const TENANT_ID = tenantId;

  console.log('🟢 SCRIPT: Constants set:', {
    BACKEND_URL,
    STORYFRAGMENT_ID,
    TENANT_ID,
  });

  let sessionId = '';
  let eventSource = null;
  let sseReconnectAttempts = 0;
  const maxReconnectDelay = 30000; // 30 seconds max
  const maxReconnectAttempts = 10; // Stop after 10 attempts
  let reconnectTimeout = null; // Track pending reconnect timeout

  console.log('🟢 SCRIPT: Variables initialized');

  async function initializeSessionAndSSE() {
    console.log('🔵 INIT: Starting session and SSE initialization');

    try {
      console.log('🔵 INIT: Getting session ID');
      sessionId = getOrCreateSessionId();
      console.log('🔵 INIT: Session ID obtained:', sessionId);

      console.log('🔵 INIT: Waiting for session ready');
      await waitForSessionReady();
      console.log('🔵 INIT: Session ready confirmed');

      console.log('🔵 INIT: Updating HTMX headers');
      updateHTMXHeaders();
      console.log('🔵 INIT: HTMX headers updated');

      console.log('🔵 INIT: Setting up SSE connection');
      setupSSEConnection();
      console.log('🔵 INIT: SSE setup complete');
    } catch (error) {
      console.error('🔴 INIT ERROR:', error);
    }
  }

  function waitForSessionReady() {
    console.log('⏳ SESSION: Checking if session is ready');

    return new Promise((resolve) => {
      if (window.TRACTSTACK_CONFIG?.session?.isReady) {
        console.log('✅ SESSION: Already ready');
        resolve();
      } else {
        console.log('⏳ SESSION: Waiting for session-ready event');
        window.addEventListener(
          'tractstack:session-ready',
          () => {
            console.log('✅ SESSION: Ready event received');
            resolve();
          },
          { once: true }
        );
      }
    });
  }

  function getOrCreateSessionId() {
    console.log('🆔 SESSION_ID: Getting or creating session ID');

    const SESSION_KEY = 'tractstack_session_id';
    let sessionId = localStorage.getItem(SESSION_KEY);

    if (!sessionId) {
      console.log('🆔 SESSION_ID: No existing session, creating new one');
      const timestamp = Date.now();
      const random = Math.random().toString(36).substring(2, 11);
      sessionId = `sess_${timestamp}_${random}`;
      localStorage.setItem(SESSION_KEY, sessionId);
      console.log('🆔 SESSION_ID: New session created:', sessionId);
    } else {
      console.log('🆔 SESSION_ID: Using existing session:', sessionId);
    }

    return sessionId;
  }

  function updateHTMXHeaders() {
    console.log('📋 HTMX: Updating headers for pane containers');

    const paneContainers = document.querySelectorAll('[data-pane-id]');
    console.log('📋 HTMX: Found', paneContainers.length, 'pane containers');

    paneContainers.forEach((container, index) => {
      const paneId = container.getAttribute('data-pane-id');
      console.log(
        `📋 HTMX: [${index + 1}/${paneContainers.length}] Updating headers for pane:`,
        paneId
      );

      const headers = JSON.stringify({
        'X-TractStack-Session-ID': sessionId,
        'X-StoryFragment-ID': STORYFRAGMENT_ID,
        'X-Tenant-ID': TENANT_ID,
      });
      container.setAttribute('hx-headers', headers);
    });

    console.log('📋 HTMX: Headers update complete');
  }

  function setupSSEConnection() {
    console.log('🔌 SSE: Setting up connection');

    // Clear any pending reconnect timeout
    if (reconnectTimeout) {
      console.log('🔌 SSE: Clearing existing reconnect timeout');
      clearTimeout(reconnectTimeout);
      reconnectTimeout = null;
    }

    if (eventSource) {
      console.log('🔌 SSE: Closing existing connection');
      eventSource.close();
    }

    const sseUrl = `${BACKEND_URL}/api/v1/auth/sse?storyfragment=${STORYFRAGMENT_ID}&sessionId=${sessionId}`;
    console.log('🔌 SSE: Creating EventSource with URL:', sseUrl);

    eventSource = new EventSource(sseUrl);

    eventSource.onopen = function (event) {
      console.log(
        '✅ SSE: Connection opened for storyfragment:',
        STORYFRAGMENT_ID
      );
      console.log('✅ SSE: Open event details:', event);
      // Reset retry counter on successful connection
      sseReconnectAttempts = 0;
    };

    eventSource.addEventListener('panes_updated', function (event) {
      console.log('📨 SSE: === PANES_UPDATED EVENT RECEIVED ===');
      console.log('📨 SSE: Raw event data:', event.data);

      try {
        const data = JSON.parse(event.data);
        console.log('📨 SSE: Parsed data:', data);
        console.log('📨 SSE: Current storyfragment:', STORYFRAGMENT_ID);
        console.log('📨 SSE: Event storyfragment:', data.storyfragmentId);
        console.log('📨 SSE: Affected panes:', data.affectedPanes);

        if (data.storyfragmentId === STORYFRAGMENT_ID) {
          console.log('✅ SSE: Storyfragment matches, processing updates');

          if (data.affectedPanes && Array.isArray(data.affectedPanes)) {
            console.log(
              `🔄 SSE: Processing ${data.affectedPanes.length} pane updates`
            );

            data.affectedPanes.forEach((paneId, index) => {
              console.log(
                `🔄 SSE: [${index + 1}/${data.affectedPanes.length}] Looking for pane: ${paneId}`
              );

              const element = document.querySelector(
                `[data-pane-id="${paneId}"]`
              );
              if (element) {
                console.log(
                  `✅ SSE: Found element for pane ${paneId}, triggering refresh`
                );
                console.log(`🔄 SSE: Element details:`, element);

                if (typeof htmx !== 'undefined') {
                  console.log(
                    `🔄 SSE: HTMX available, triggering refresh for pane ${paneId}`
                  );
                  htmx.trigger(element, 'refresh');
                  console.log(`✅ SSE: Refresh triggered for pane ${paneId}`);
                } else {
                  console.error(
                    `🔴 SSE: HTMX not available! Cannot trigger refresh for pane ${paneId}`
                  );
                }
              } else {
                console.warn(`❌ SSE: Element not found for pane: ${paneId}`);
                // Also log all available pane elements for debugging
                const allPanes = document.querySelectorAll('[data-pane-id]');
                console.log(
                  '🔍 SSE: Available panes:',
                  Array.from(allPanes).map((el) =>
                    el.getAttribute('data-pane-id')
                  )
                );
              }
            });
          } else {
            console.warn('❌ SSE: No affectedPanes array found in event data');
          }
        } else {
          console.log(
            `❌ SSE: Ignoring event for different storyfragment: ${data.storyfragmentId}`
          );
        }
      } catch (parseError) {
        console.error('🔴 SSE: Error parsing event data:', parseError);
        console.error('🔴 SSE: Raw data was:', event.data);
      }

      console.log('📨 SSE: === END PANES_UPDATED EVENT ===');
    });

    eventSource.addEventListener('connected', function (event) {
      console.log('🔗 SSE: Connected event received');
      console.log('🔗 SSE: Event data:', event.data);

      try {
        const data = JSON.parse(event.data);
        console.log(
          '🔗 SSE: Connected - Session:',
          data.sessionId,
          'Tenant:',
          data.tenantId,
          'Storyfragment:',
          data.storyfragmentId
        );
      } catch (parseError) {
        console.error('🔴 SSE: Error parsing connected event:', parseError);
      }
    });

    eventSource.addEventListener('heartbeat', function (event) {
      console.log('💓 SSE: Heartbeat received');

      try {
        const data = JSON.parse(event.data);
        console.log(
          '💓 SSE: Heartbeat - Session:',
          data.sessionId,
          'Tenant:',
          data.tenantId
        );
      } catch (parseError) {
        console.error('🔴 SSE: Error parsing heartbeat:', parseError);
      }
    });

    eventSource.addEventListener('timeout', function (event) {
      console.log('⏰ SSE: Timeout event received');

      try {
        const data = JSON.parse(event.data);
        if (data.reason === 'max_duration' && data.action === 'reconnect') {
          console.log(
            '⏰ SSE: Connection reached 30-minute limit, reconnecting immediately...'
          );
          eventSource.close(); // Close current connection
          setupSSEConnection(); // Immediate reconnect
        } else if (data.reason === 'inactivity') {
          console.log('⏰ SSE: Connection closed due to inactivity');
          // Could show user a message about inactivity
        }
      } catch (parseError) {
        console.error('🔴 SSE: Error parsing timeout event:', parseError);
      }
    });

    eventSource.onerror = function (event) {
      console.error('🔴 SSE: Error event received:', event);

      // Close immediately to stop EventSource auto-reconnects
      eventSource.close();

      sseReconnectAttempts++;

      if (sseReconnectAttempts > maxReconnectAttempts) {
        console.error(
          `🔴 SSE: Connection failed after ${maxReconnectAttempts} attempts. Giving up.`
        );
        return;
      }

      // Exponential backoff: 1s, 2s, 4s, 8s, 16s, 30s (max)
      const delay = Math.min(
        1000 * Math.pow(2, sseReconnectAttempts - 1),
        maxReconnectDelay
      );

      console.error(
        `🔴 SSE: Connection error (attempt ${sseReconnectAttempts}/${maxReconnectAttempts}). Retrying in ${delay}ms...`
      );

      // Store the timeout so we can clear it later
      reconnectTimeout = setTimeout(() => {
        console.log('🔄 SSE: Retrying connection...');
        reconnectTimeout = null;
        setupSSEConnection();
      }, delay);
    };

    console.log('🔌 SSE: Event listeners attached');
  }

  console.log('🟢 SCRIPT: Checking document ready state:', document.readyState);

  if (document.readyState === 'loading') {
    console.log(
      '⏳ SCRIPT: Document still loading, adding DOMContentLoaded listener'
    );
    document.addEventListener('DOMContentLoaded', () => {
      console.log('✅ SCRIPT: DOMContentLoaded fired, initializing');
      initializeSessionAndSSE();
    });
  } else {
    console.log('✅ SCRIPT: Document already loaded, initializing immediately');
    initializeSessionAndSSE();
  }

  window.addEventListener('beforeunload', function () {
    console.log('👋 SCRIPT: Page unloading, cleaning up');

    if (reconnectTimeout) {
      console.log('🧹 SCRIPT: Clearing reconnect timeout');
      clearTimeout(reconnectTimeout);
    }
    if (eventSource) {
      console.log('🧹 SCRIPT: Closing SSE connection');
      eventSource.close();
    }
  });

  console.log('🟢 SCRIPT END: Setup complete');
</script>
